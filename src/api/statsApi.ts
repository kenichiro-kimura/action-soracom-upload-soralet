/**
 * SORACOM API
 * SORACOM API v1
 *
 * The version of the OpenAPI document: 20230427-035008
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { AirAggregatedStatsResponse } from '../model/airAggregatedStatsResponse';
import { AirStatsResponse } from '../model/airStatsResponse';
import { BeamStatsResponse } from '../model/beamStatsResponse';
import { ExportRequest } from '../model/exportRequest';
import { FileExportResponse } from '../model/fileExportResponse';
import { FunkStatsResponse } from '../model/funkStatsResponse';
import { FunnelStatsResponse } from '../model/funnelStatsResponse';
import { HarvestExportedDataStatsResponse } from '../model/harvestExportedDataStatsResponse';
import { HarvestStatsResponse } from '../model/harvestStatsResponse';
import { NapterAuditLogsExportedDataStatsResponse } from '../model/napterAuditLogsExportedDataStatsResponse';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';
import { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://api.soracom.io/v1';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum StatsApiApiKeys {
    api_key,
    api_token,
}

export class StatsApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'api_key': new ApiKeyAuth('header', 'X-Soracom-API-Key'),
        'api_token': new ApiKeyAuth('header', 'X-Soracom-Token'),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: StatsApiApiKeys, value: string) {
        (this.authentications as any)[StatsApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * オペレーターが所有していたすべての IoT SIM のデータ通信量を、[Air データ通信量実績データ CSV](/ja-jp/docs/air/stats-csv/) でダウンロードします。  **Info**: 解約した IoT SIM のデータ通信量も確認できます。 
     * @summary すべての IoT SIM のデータ通信量をエクスポートする
     * @param operatorId オペレーター ID
     * @param exportRequest 出力するデータの期間
     * @param exportMode Air データ通信量実績データ CSV をダウンロードするための URL を取得する方法を指定します。  - &#x60;async&#x60;: SORACOM プラットフォームで URL が発行されるのを待たずに、&#x60;exportedFieldId&#x60; を取得します。この &#x60;exportedFieldId&#x60; を [&#x60;Files:getExportedFile API&#x60;](#/Files/getExportedFile) で指定すると、URL を取得できます。Air データ通信量実績データ CSV のファイルサイズが大きい場合は、&#x60;async&#x60; を利用してください。 - &#x60;sync&#x60; (デフォルト): SORACOM プラットフォームで URL が発行されるのを待ちます。ただし、Air データ通信量実績データ CSV のファイルサイズが大きい場合など、タイムアウトして URL を取得できないことがあります。タイムアウトする場合は、&#x60;async&#x60; を指定してください。 
     */
    public async exportAirStats (operatorId: string, exportRequest: ExportRequest, exportMode?: 'async' | 'sync', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FileExportResponse;  }> {
        const localVarPath = this.basePath + '/stats/air/operators/{operator_id}/export'
            .replace('{' + 'operator_id' + '}', encodeURIComponent(String(operatorId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'operatorId' is not null or undefined
        if (operatorId === null || operatorId === undefined) {
            throw new Error('Required parameter operatorId was null or undefined when calling exportAirStats.');
        }

        // verify required parameter 'exportRequest' is not null or undefined
        if (exportRequest === null || exportRequest === undefined) {
            throw new Error('Required parameter exportRequest was null or undefined when calling exportAirStats.');
        }

        if (exportMode !== undefined) {
            localVarQueryParameters['export_mode'] = ObjectSerializer.serialize(exportMode, "'async' | 'sync'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(exportRequest, "ExportRequest")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.api_key.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.api_token.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_token.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: FileExportResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "FileExportResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Operator が保有する全 Subscriber の SORACOM Beam 利用量履歴をファイルで取得する。取得対象の期間は from, to の unixtime で指定する。履歴の詳細度は月単位。ファイルの出力先は AWS S3。ファイルの出力形式は CSV。
     * @summary すべての Subscriber の SORACOM Beam 利用量履歴をエクスポートする
     * @param operatorId operator ID
     * @param exportRequest 出力するデータの期間
     * @param exportMode export_mode (async, sync)
     */
    public async exportBeamStats (operatorId: string, exportRequest: ExportRequest, exportMode?: 'async' | 'sync', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FileExportResponse;  }> {
        const localVarPath = this.basePath + '/stats/beam/operators/{operator_id}/export'
            .replace('{' + 'operator_id' + '}', encodeURIComponent(String(operatorId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'operatorId' is not null or undefined
        if (operatorId === null || operatorId === undefined) {
            throw new Error('Required parameter operatorId was null or undefined when calling exportBeamStats.');
        }

        // verify required parameter 'exportRequest' is not null or undefined
        if (exportRequest === null || exportRequest === undefined) {
            throw new Error('Required parameter exportRequest was null or undefined when calling exportBeamStats.');
        }

        if (exportMode !== undefined) {
            localVarQueryParameters['export_mode'] = ObjectSerializer.serialize(exportMode, "'async' | 'sync'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(exportRequest, "ExportRequest")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.api_key.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.api_token.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_token.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: FileExportResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "FileExportResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Operator が保有する全 Subscriber の SORACOM Funk 利用量履歴をファイルで取得する。取得対象の期間は from, to の unixtime で指定する。履歴の詳細度は月単位。ファイルの出力先は AWS S3。ファイルの出力形式は CSV。
     * @summary すべての Subscriber の SORACOM Funk 利用量履歴をエクスポートする
     * @param operatorId operator ID
     * @param exportRequest 出力するデータの期間
     * @param exportMode export_mode (async, sync)
     */
    public async exportFunkStats (operatorId: string, exportRequest: ExportRequest, exportMode?: 'async' | 'sync', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FileExportResponse;  }> {
        const localVarPath = this.basePath + '/stats/funk/operators/{operator_id}/export'
            .replace('{' + 'operator_id' + '}', encodeURIComponent(String(operatorId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'operatorId' is not null or undefined
        if (operatorId === null || operatorId === undefined) {
            throw new Error('Required parameter operatorId was null or undefined when calling exportFunkStats.');
        }

        // verify required parameter 'exportRequest' is not null or undefined
        if (exportRequest === null || exportRequest === undefined) {
            throw new Error('Required parameter exportRequest was null or undefined when calling exportFunkStats.');
        }

        if (exportMode !== undefined) {
            localVarQueryParameters['export_mode'] = ObjectSerializer.serialize(exportMode, "'async' | 'sync'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(exportRequest, "ExportRequest")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.api_key.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.api_token.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_token.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: FileExportResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "FileExportResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Operator が保有する全 Subscriber の SORACOM Funnel 利用量履歴をファイルで取得する。取得対象の期間は from, to の unixtime で指定する。履歴の詳細度は月単位。ファイルの出力先は AWS S3。ファイルの出力形式は CSV。
     * @summary すべての Subscriber の SORACOM Funnel 利用量履歴をエクスポートする
     * @param operatorId operator ID
     * @param exportRequest 出力するデータの期間
     * @param exportMode export_mode (async, sync)
     */
    public async exportFunnelStats (operatorId: string, exportRequest: ExportRequest, exportMode?: 'async' | 'sync', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FileExportResponse;  }> {
        const localVarPath = this.basePath + '/stats/funnel/operators/{operator_id}/export'
            .replace('{' + 'operator_id' + '}', encodeURIComponent(String(operatorId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'operatorId' is not null or undefined
        if (operatorId === null || operatorId === undefined) {
            throw new Error('Required parameter operatorId was null or undefined when calling exportFunnelStats.');
        }

        // verify required parameter 'exportRequest' is not null or undefined
        if (exportRequest === null || exportRequest === undefined) {
            throw new Error('Required parameter exportRequest was null or undefined when calling exportFunnelStats.');
        }

        if (exportMode !== undefined) {
            localVarQueryParameters['export_mode'] = ObjectSerializer.serialize(exportMode, "'async' | 'sync'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(exportRequest, "ExportRequest")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.api_key.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.api_token.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_token.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: FileExportResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "FileExportResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * IMSI で指定した IoT SIM のデータ通信量履歴を取得します。  **Warning**: 解約した IoT SIM のデータ通信量は確認できません。 
     * @summary IMSI で指定した IoT SIM のデータ通信量履歴を取得する
     * @param imsi imsi
     * @param from 集計対象時刻の始まりを UNIX 時間 (秒) で与える
     * @param to 集計対象時刻の終わりを UNIX 時間 (秒) で与える
     * @param period 集計単位。minutes は最も細かい粒度で通信量履歴を出力します。ただし、デバイスが SORACOM プラットフォームに接続している間は、約 5 分間隔で通信量が記録されます。
     */
    public async getAirStats (imsi: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<AirStatsResponse>;  }> {
        const localVarPath = this.basePath + '/stats/air/subscribers/{imsi}'
            .replace('{' + 'imsi' + '}', encodeURIComponent(String(imsi)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'imsi' is not null or undefined
        if (imsi === null || imsi === undefined) {
            throw new Error('Required parameter imsi was null or undefined when calling getAirStats.');
        }

        // verify required parameter 'from' is not null or undefined
        if (from === null || from === undefined) {
            throw new Error('Required parameter from was null or undefined when calling getAirStats.');
        }

        // verify required parameter 'to' is not null or undefined
        if (to === null || to === undefined) {
            throw new Error('Required parameter to was null or undefined when calling getAirStats.');
        }

        // verify required parameter 'period' is not null or undefined
        if (period === null || period === undefined) {
            throw new Error('Required parameter period was null or undefined when calling getAirStats.');
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "number");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "number");
        }

        if (period !== undefined) {
            localVarQueryParameters['period'] = ObjectSerializer.serialize(period, "'month' | 'day' | 'minutes'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.api_key.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.api_token.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_token.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<AirStatsResponse>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<AirStatsResponse>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 指定したグループに所属するすべての IoT SIM を集約したデータ通信量履歴を取得します。
     * @summary 指定したグループに所属するすべての IoT SIM を集約したデータ通信量履歴を取得する
     * @param groupId グループ ID
     * @param from 集計対象期間の開始月/日を UNIX 時間 (秒) で指定します。なお、&#x60;period&#x60; の値によって指定できる値および動作が異なります。  - &#x60;period&#x60; が &#x60;month&#x60; の場合:   - 現在時刻の 3 か月前 〜 現在時刻の UNIX 時間 (秒) を指定してください。   - 実際の集計対象期間の開始時刻は、指定した UNIX 時間 (秒) を含む月の 1 日 00:00:00 です。 - &#x60;period&#x60; が &#x60;day&#x60; の場合:   - 現在時刻の 6 日前 〜 現在時刻の UNIX 時間 (秒) を指定してください。   - 実際の集計対象期間の開始時刻は、指定した UNIX 時間 (秒) を含む日の 00:00:00 です。 
     * @param to 集計対象期間の終了月/日を UNIX 時間 (秒) で指定します。なお、&#x60;period&#x60; の値によって指定できる値および動作が異なります。  - &#x60;period&#x60; が &#x60;month&#x60; の場合:   - 現在時刻の 3 か月前 〜 現在時刻の UNIX 時間 (秒) を指定してください。   - 実際の集計対象期間の終了時刻は、指定した UNIX 時間 (秒) を含む月の月末の 24:00:00 です。 - &#x60;period&#x60; が &#x60;day&#x60; の場合:   - 現在時刻の 6 日前 〜 現在時刻の UNIX 時間 (秒) を指定してください。   - 実際の集計対象期間の終了時刻は、指定した UNIX 時間 (秒) を含む日の 24:00:00 です。 
     * @param period 集計単位。  - month: 月ごとに集計します。 - day: 日ごとに集計します。 
     */
    public async getAirStatsOfGroup (groupId: string, from: number, to: number, period: 'month' | 'day', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<AirAggregatedStatsResponse>;  }> {
        const localVarPath = this.basePath + '/stats/air/groups/{group_id}'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling getAirStatsOfGroup.');
        }

        // verify required parameter 'from' is not null or undefined
        if (from === null || from === undefined) {
            throw new Error('Required parameter from was null or undefined when calling getAirStatsOfGroup.');
        }

        // verify required parameter 'to' is not null or undefined
        if (to === null || to === undefined) {
            throw new Error('Required parameter to was null or undefined when calling getAirStatsOfGroup.');
        }

        // verify required parameter 'period' is not null or undefined
        if (period === null || period === undefined) {
            throw new Error('Required parameter period was null or undefined when calling getAirStatsOfGroup.');
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "number");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "number");
        }

        if (period !== undefined) {
            localVarQueryParameters['period'] = ObjectSerializer.serialize(period, "'month' | 'day'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.api_key.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.api_token.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_token.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<AirAggregatedStatsResponse>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<AirAggregatedStatsResponse>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 指定したオペレーターが保有するすべての IoT SIM を集約したデータ通信量履歴を取得します。
     * @summary 指定したオペレーターが保有するすべての IoT SIM を集約したデータ通信量履歴を取得する
     * @param operatorId オペレーター ID
     * @param from 集計対象期間の開始月/日を UNIX 時間 (秒) で指定します。なお、&#x60;period&#x60; の値によって指定できる値および動作が異なります。  - &#x60;period&#x60; が &#x60;month&#x60; の場合:   - 現在時刻の 3 か月前 〜 現在時刻の UNIX 時間 (秒) を指定してください。   - 実際の集計対象期間の開始時刻は、指定した UNIX 時間 (秒) を含む月の 1 日 00:00:00 です。 - &#x60;period&#x60; が &#x60;day&#x60; の場合:   - 現在時刻の 6 日前 〜 現在時刻の UNIX 時間 (秒) を指定してください。   - 実際の集計対象期間の開始時刻は、指定した UNIX 時間 (秒) を含む日の 00:00:00 です。 
     * @param to 集計対象期間の終了月/日を UNIX 時間 (秒) で指定します。なお、&#x60;period&#x60; の値によって指定できる値および動作が異なります。  - &#x60;period&#x60; が &#x60;month&#x60; の場合:   - 現在時刻の 3 か月前 〜 現在時刻の UNIX 時間 (秒) を指定してください。   - 実際の集計対象期間の終了時刻は、指定した UNIX 時間 (秒) を含む月の月末の 24:00:00 です。 - &#x60;period&#x60; が &#x60;day&#x60; の場合:   - 現在時刻の 6 日前 〜 現在時刻の UNIX 時間 (秒) を指定してください。   - 実際の集計対象期間の終了時刻は、指定した UNIX 時間 (秒) を含む日の 24:00:00 です。 
     * @param period 集計単位。  - month: 月ごとに集計します。 - day: 日ごとに集計します。 
     */
    public async getAirStatsOfOperator (operatorId: string, from: number, to: number, period: 'month' | 'day', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<AirAggregatedStatsResponse>;  }> {
        const localVarPath = this.basePath + '/stats/air/operators/{operator_id}'
            .replace('{' + 'operator_id' + '}', encodeURIComponent(String(operatorId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'operatorId' is not null or undefined
        if (operatorId === null || operatorId === undefined) {
            throw new Error('Required parameter operatorId was null or undefined when calling getAirStatsOfOperator.');
        }

        // verify required parameter 'from' is not null or undefined
        if (from === null || from === undefined) {
            throw new Error('Required parameter from was null or undefined when calling getAirStatsOfOperator.');
        }

        // verify required parameter 'to' is not null or undefined
        if (to === null || to === undefined) {
            throw new Error('Required parameter to was null or undefined when calling getAirStatsOfOperator.');
        }

        // verify required parameter 'period' is not null or undefined
        if (period === null || period === undefined) {
            throw new Error('Required parameter period was null or undefined when calling getAirStatsOfOperator.');
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "number");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "number");
        }

        if (period !== undefined) {
            localVarQueryParameters['period'] = ObjectSerializer.serialize(period, "'month' | 'day'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.api_key.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.api_token.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_token.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<AirAggregatedStatsResponse>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<AirAggregatedStatsResponse>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * SIM ID で指定した SIM のデータ通信量履歴を取得します。  **Warning**: 解約した IoT SIM のデータ通信量は確認できません。 
     * @summary SIM ID で指定した IoT SIM のデータ通信量履歴を取得する
     * @param simId SIM ID
     * @param from 集計対象時刻の始まりを UNIX 時間 (秒) で与える
     * @param to 集計対象時刻の終わりを UNIX 時間 (秒) で与える
     * @param period 集計単位。minutes は最も細かい粒度で通信量履歴を出力します。ただし、デバイスが SORACOM プラットフォームに接続している間は、約 5 分間隔で通信量が記録されます。
     */
    public async getAirStatsOfSim (simId: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<AirStatsResponse>;  }> {
        const localVarPath = this.basePath + '/stats/air/sims/{sim_id}'
            .replace('{' + 'sim_id' + '}', encodeURIComponent(String(simId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'simId' is not null or undefined
        if (simId === null || simId === undefined) {
            throw new Error('Required parameter simId was null or undefined when calling getAirStatsOfSim.');
        }

        // verify required parameter 'from' is not null or undefined
        if (from === null || from === undefined) {
            throw new Error('Required parameter from was null or undefined when calling getAirStatsOfSim.');
        }

        // verify required parameter 'to' is not null or undefined
        if (to === null || to === undefined) {
            throw new Error('Required parameter to was null or undefined when calling getAirStatsOfSim.');
        }

        // verify required parameter 'period' is not null or undefined
        if (period === null || period === undefined) {
            throw new Error('Required parameter period was null or undefined when calling getAirStatsOfSim.');
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "number");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "number");
        }

        if (period !== undefined) {
            localVarQueryParameters['period'] = ObjectSerializer.serialize(period, "'month' | 'day' | 'minutes'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.api_key.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.api_token.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_token.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<AirStatsResponse>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<AirStatsResponse>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * IMSI で指定した Subscriber の SORACOM Beam 利用量履歴を取得する。
     * @summary IMSI で指定した Subscriber の SORACOM Beam 利用量履歴を取得する
     * @param imsi imsi
     * @param from 集計対象時刻の始まりを UNIX 時間 (秒) で与える
     * @param to 集計対象時刻の終わりを UNIX 時間 (秒) で与える
     * @param period 集計単位。minutes は最も細かい粒度で利用量履歴を出力します。ただし、デバイスが SORACOM プラットフォームに接続している間は、約 5 分間隔で利用量が記録されます。
     */
    public async getBeamStats (imsi: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<BeamStatsResponse>;  }> {
        const localVarPath = this.basePath + '/stats/beam/subscribers/{imsi}'
            .replace('{' + 'imsi' + '}', encodeURIComponent(String(imsi)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'imsi' is not null or undefined
        if (imsi === null || imsi === undefined) {
            throw new Error('Required parameter imsi was null or undefined when calling getBeamStats.');
        }

        // verify required parameter 'from' is not null or undefined
        if (from === null || from === undefined) {
            throw new Error('Required parameter from was null or undefined when calling getBeamStats.');
        }

        // verify required parameter 'to' is not null or undefined
        if (to === null || to === undefined) {
            throw new Error('Required parameter to was null or undefined when calling getBeamStats.');
        }

        // verify required parameter 'period' is not null or undefined
        if (period === null || period === undefined) {
            throw new Error('Required parameter period was null or undefined when calling getBeamStats.');
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "number");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "number");
        }

        if (period !== undefined) {
            localVarQueryParameters['period'] = ObjectSerializer.serialize(period, "'month' | 'day' | 'minutes'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.api_key.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.api_token.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_token.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<BeamStatsResponse>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<BeamStatsResponse>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * IMSI で指定した Subscriber の SORACOM Funk 利用量履歴を取得する。
     * @summary IMSI で指定した Subscriber の SORACOM Funk 利用量履歴を取得する
     * @param imsi imsi
     * @param from 集計対象時刻の始まりを UNIX 時間 (秒) で与える
     * @param to 集計対象時刻の終わりを UNIX 時間 (秒) で与える
     * @param period 集計単位。minutes は最も細かい粒度で利用量履歴を出力します。ただし、デバイスが SORACOM プラットフォームに接続している間は、約 5 分間隔で利用量が記録されます。
     */
    public async getFunkStats (imsi: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<FunkStatsResponse>;  }> {
        const localVarPath = this.basePath + '/stats/funk/subscribers/{imsi}'
            .replace('{' + 'imsi' + '}', encodeURIComponent(String(imsi)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'imsi' is not null or undefined
        if (imsi === null || imsi === undefined) {
            throw new Error('Required parameter imsi was null or undefined when calling getFunkStats.');
        }

        // verify required parameter 'from' is not null or undefined
        if (from === null || from === undefined) {
            throw new Error('Required parameter from was null or undefined when calling getFunkStats.');
        }

        // verify required parameter 'to' is not null or undefined
        if (to === null || to === undefined) {
            throw new Error('Required parameter to was null or undefined when calling getFunkStats.');
        }

        // verify required parameter 'period' is not null or undefined
        if (period === null || period === undefined) {
            throw new Error('Required parameter period was null or undefined when calling getFunkStats.');
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "number");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "number");
        }

        if (period !== undefined) {
            localVarQueryParameters['period'] = ObjectSerializer.serialize(period, "'month' | 'day' | 'minutes'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.api_key.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.api_token.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_token.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<FunkStatsResponse>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<FunkStatsResponse>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * IMSI で指定した Subscriber の SORACOM Funnel 利用量履歴を取得する。
     * @summary IMSI で指定した Subscriber の SORACOM Funnel 利用量履歴を取得する
     * @param imsi imsi
     * @param from 集計対象時刻の始まりを UNIX 時間 (秒) で与える
     * @param to 集計対象時刻の終わりを UNIX 時間 (秒) で与える
     * @param period 集計単位。minutes は最も細かい粒度で利用量履歴を出力します。ただし、デバイスが SORACOM プラットフォームに接続している間は、約 5 分間隔で利用量が記録されます。
     */
    public async getFunnelStats (imsi: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<FunnelStatsResponse>;  }> {
        const localVarPath = this.basePath + '/stats/funnel/subscribers/{imsi}'
            .replace('{' + 'imsi' + '}', encodeURIComponent(String(imsi)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'imsi' is not null or undefined
        if (imsi === null || imsi === undefined) {
            throw new Error('Required parameter imsi was null or undefined when calling getFunnelStats.');
        }

        // verify required parameter 'from' is not null or undefined
        if (from === null || from === undefined) {
            throw new Error('Required parameter from was null or undefined when calling getFunnelStats.');
        }

        // verify required parameter 'to' is not null or undefined
        if (to === null || to === undefined) {
            throw new Error('Required parameter to was null or undefined when calling getFunnelStats.');
        }

        // verify required parameter 'period' is not null or undefined
        if (period === null || period === undefined) {
            throw new Error('Required parameter period was null or undefined when calling getFunnelStats.');
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "number");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "number");
        }

        if (period !== undefined) {
            localVarQueryParameters['period'] = ObjectSerializer.serialize(period, "'month' | 'day' | 'minutes'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.api_key.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.api_token.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_token.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<FunnelStatsResponse>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<FunnelStatsResponse>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 指定された Operator の指定された年月における Harvest データの読み込みデータ通信量を byte 単位で取得します。
     * @summary Harvest の利用統計情報を取得する
     * @param operatorId operator ID
     * @param yearMonth 年月を YYYYMM 形式で指定します。
     */
    public async getHarvestExportedDataStats (operatorId: string, yearMonth?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: HarvestExportedDataStatsResponse;  }> {
        const localVarPath = this.basePath + '/stats/harvest/operators/{operator_id}'
            .replace('{' + 'operator_id' + '}', encodeURIComponent(String(operatorId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'operatorId' is not null or undefined
        if (operatorId === null || operatorId === undefined) {
            throw new Error('Required parameter operatorId was null or undefined when calling getHarvestExportedDataStats.');
        }

        if (yearMonth !== undefined) {
            localVarQueryParameters['year_month'] = ObjectSerializer.serialize(yearMonth, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.api_key.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.api_token.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_token.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: HarvestExportedDataStatsResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "HarvestExportedDataStatsResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * IMSI で指定した Subscriber の SORACOM Harvest Data 利用量履歴を取得する。
     * @summary IMSI で指定した Subscriber の SORACOM Harvest Data 利用量履歴を取得する
     * @param imsi imsi
     * @param from 集計対象時刻の始まりを UNIX 時間 (秒) で与える
     * @param to 集計対象時刻の終わりを UNIX 時間 (秒) で与える
     * @param period 集計単位。minutes は最も細かい粒度で利用量履歴を出力します。ただし、デバイスが SORACOM プラットフォームに接続している間は、約 5 分間隔で利用量が記録されます。
     */
    public async getHarvestStats (imsi: string, from: number, to: number, period: 'month' | 'day' | 'minutes', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<HarvestStatsResponse>;  }> {
        const localVarPath = this.basePath + '/stats/harvest/subscribers/{imsi}'
            .replace('{' + 'imsi' + '}', encodeURIComponent(String(imsi)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'imsi' is not null or undefined
        if (imsi === null || imsi === undefined) {
            throw new Error('Required parameter imsi was null or undefined when calling getHarvestStats.');
        }

        // verify required parameter 'from' is not null or undefined
        if (from === null || from === undefined) {
            throw new Error('Required parameter from was null or undefined when calling getHarvestStats.');
        }

        // verify required parameter 'to' is not null or undefined
        if (to === null || to === undefined) {
            throw new Error('Required parameter to was null or undefined when calling getHarvestStats.');
        }

        // verify required parameter 'period' is not null or undefined
        if (period === null || period === undefined) {
            throw new Error('Required parameter period was null or undefined when calling getHarvestStats.');
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "number");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "number");
        }

        if (period !== undefined) {
            localVarQueryParameters['period'] = ObjectSerializer.serialize(period, "'month' | 'day' | 'minutes'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.api_key.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.api_token.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_token.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<HarvestStatsResponse>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<HarvestStatsResponse>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 指定された年月における Napter 監査ログの読み込みデータ通信量を byte 単位で取得する。
     * @summary Napter 監査ログの月次読み込みデータ量を取得する
     * @param yearMonth 年月を YYYYMM 形式で指定します。
     */
    public async getNapterAuditLogsExportedDataStats (yearMonth?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: NapterAuditLogsExportedDataStatsResponse;  }> {
        const localVarPath = this.basePath + '/stats/napter/audit_logs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (yearMonth !== undefined) {
            localVarQueryParameters['year_month'] = ObjectSerializer.serialize(yearMonth, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.api_key.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.api_token.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_token.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: NapterAuditLogsExportedDataStatsResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "NapterAuditLogsExportedDataStatsResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
