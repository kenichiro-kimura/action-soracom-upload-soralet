/**
 * SORACOM API
 * SORACOM API v1
 *
 * The version of the OpenAPI document: 20230427-035008
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { Device } from '../model/device';
import { SigfoxDevice } from '../model/sigfoxDevice';
import { Sim } from '../model/sim';
import { Subscriber } from '../model/subscriber';
import { TrafficVolumeRanking } from '../model/trafficVolumeRanking';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';
import { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://api.soracom.io/v1';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum QueryApiApiKeys {
    api_key,
    api_token,
}

export class QueryApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'api_key': new ApiKeyAuth('header', 'X-Soracom-API-Key'),
        'api_token': new ApiKeyAuth('header', 'X-Soracom-Token'),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: QueryApiApiKeys, value: string) {
        (this.authentications as any)[QueryApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * SORACOM Inventory デバイスをクエリに応じて検索します。部分一致したものを返却します。この API 権限が付与された場合、すべての SORACOM Inventory デバイスに対して group も含めた検索/一覧取得を行える権限が与えられます。
     * @summary SORACOM Inventory デバイスをクエリに応じて検索する
     * @param name 検索する SORACOM Inventory デバイスの名前
     * @param group 検索するグループの名前
     * @param deviceId 検索する SORACOM Inventory デバイスの ID
     * @param tag 検索するタグの値の文字列
     * @param imsi 検索する SORACOM Inventory デバイスの bootstrap 時の IMSI
     * @param imei 検索する SORACOM Inventory デバイスの bootstrap 時の IMEI
     * @param limit 取得する結果の上限数
     * @param lastEvaluatedKey 現ページで取得した最後の SORACOM Inventory デバイスの ID。このパラメータを指定することで次の SORACOM Inventory デバイス以降のリストを取得できる。
     * @param searchType 検索の種別 (AND 検索もしくは OR 検索)
     */
    public async searchDevices (name?: Array<string>, group?: Array<string>, deviceId?: Array<string>, tag?: Array<string>, imsi?: Array<string>, imei?: Array<string>, limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Device>;  }> {
        const localVarPath = this.basePath + '/query/devices';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "Array<string>");
        }

        if (group !== undefined) {
            localVarQueryParameters['group'] = ObjectSerializer.serialize(group, "Array<string>");
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "Array<string>");
        }

        if (tag !== undefined) {
            localVarQueryParameters['tag'] = ObjectSerializer.serialize(tag, "Array<string>");
        }

        if (imsi !== undefined) {
            localVarQueryParameters['imsi'] = ObjectSerializer.serialize(imsi, "Array<string>");
        }

        if (imei !== undefined) {
            localVarQueryParameters['imei'] = ObjectSerializer.serialize(imei, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (lastEvaluatedKey !== undefined) {
            localVarQueryParameters['last_evaluated_key'] = ObjectSerializer.serialize(lastEvaluatedKey, "string");
        }

        if (searchType !== undefined) {
            localVarQueryParameters['search_type'] = ObjectSerializer.serialize(searchType, "'and' | 'or'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.api_key.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.api_token.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_token.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Device>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Device>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Sigfox デバイスをクエリに応じて検索します。部分一致したものを返却します。この API 権限が付与された場合、すべての Sigfox デバイスに対して group も含めた検索/一覧取得を行える権限が与えられます。
     * @summary Sigfox デバイスをクエリに応じて検索する
     * @param name 検索する Sigfox デバイスの名前
     * @param group 検索するグループの名前
     * @param deviceId 検索する Sigfox デバイスの ID
     * @param tag 検索するタグの値の文字列
     * @param status 検索する Sigfox デバイスの状態
     * @param registration 検索する Sigfox デバイスの登録状態
     * @param limit 取得する結果の上限数
     * @param lastEvaluatedKey 現ページで取得した最後の Sigfox デバイスの ID。このパラメータを指定することで次の Sigfox デバイス以降のリストを取得できる。
     * @param searchType 検索の種別 (AND 検索もしくは OR 検索)
     */
    public async searchSigfoxDevices (name?: Array<string>, group?: Array<string>, deviceId?: Array<string>, tag?: Array<string>, status?: 'active' | 'inactive' | 'suspended' | 'terminated' | 'shipped' | 'ready' | 'inStock' | 'banned' | 'standby', registration?: 'notStarted' | 'pending' | 'success' | 'failed', limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<SigfoxDevice>;  }> {
        const localVarPath = this.basePath + '/query/sigfox_devices';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "Array<string>");
        }

        if (group !== undefined) {
            localVarQueryParameters['group'] = ObjectSerializer.serialize(group, "Array<string>");
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "Array<string>");
        }

        if (tag !== undefined) {
            localVarQueryParameters['tag'] = ObjectSerializer.serialize(tag, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'active' | 'inactive' | 'suspended' | 'terminated' | 'shipped' | 'ready' | 'inStock' | 'banned' | 'standby'");
        }

        if (registration !== undefined) {
            localVarQueryParameters['registration'] = ObjectSerializer.serialize(registration, "'notStarted' | 'pending' | 'success' | 'failed'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (lastEvaluatedKey !== undefined) {
            localVarQueryParameters['last_evaluated_key'] = ObjectSerializer.serialize(lastEvaluatedKey, "string");
        }

        if (searchType !== undefined) {
            localVarQueryParameters['search_type'] = ObjectSerializer.serialize(searchType, "'and' | 'or'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.api_key.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.api_token.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_token.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<SigfoxDevice>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<SigfoxDevice>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * クエリパラメータに指定した条件で、IoT SIM を検索します。部分一致で検索できます。大文字と小文字は区別されません。  **Warning**: SAM ユーザーに、この API を呼び出す権限が付与された場合は、その SAM ユーザーにはすべての IoT SIM に対してグループも含めた検索 / 一覧取得を行う権限が与えられます。 
     * @summary SIM をクエリに応じて検索する
     * @param name IoT SIM の名前。
     * @param group IoT SIM が所属する [グループ](/ja-jp/docs/group-configuration/) の名前。
     * @param simId [SIM ID](/ja-jp/resources/glossary/#sim-id)。
     * @param imsi [IMSI (International Mobile Subscriber Identity)](/ja-jp/resources/glossary/#imsi-international-mobile-subscriber-identity)。
     * @param msisdn [MSISDN (Mobile Station International Subscriber Directory Number)](/ja-jp/resources/glossary/#msisdn-mobile-station-international-subscriber-directory-number)。
     * @param iccid ICCID (Integrated Circuit Card ID)。SIM カードや仮想的な IoT SIM (バーチャル SIM/Subscriber) を識別するための識別子。
     * @param serialNumber IoT SIM の裏面に記載された製造番号。特定地域向け IoT SIM にのみ設定されています。
     * @param tag IoT SIM のタグの値の文字列。詳しくは、[IoT SIM に付加情報 (タグ) を設定する](/ja-jp/docs/air/set-tag/) を参照してください。
     * @param bundles バンドル
     * @param sessionStatus セッションの状態 - &#x60;NA&#x60;: 任意 - &#x60;ONLINE&#x60;: オンライン - &#x60;OFFLINE&#x60;: オフライン 
     * @param limit 取得する結果の上限数
     * @param lastEvaluatedKey 現ページで取得した最後の SIM の SIM ID。このパラメータを指定することで次の SIM 以降のリストを取得できる。
     * @param searchType 検索の種別 (AND 検索もしくは OR 検索)。省略した場合は、AND 検索です。
     */
    public async searchSims (name?: Array<string>, group?: Array<string>, simId?: Array<string>, imsi?: Array<string>, msisdn?: Array<string>, iccid?: Array<string>, serialNumber?: Array<string>, tag?: Array<string>, bundles?: Array<string>, sessionStatus?: 'NA' | 'ONLINE' | 'OFFLINE', limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Sim>;  }> {
        const localVarPath = this.basePath + '/query/sims';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "Array<string>");
        }

        if (group !== undefined) {
            localVarQueryParameters['group'] = ObjectSerializer.serialize(group, "Array<string>");
        }

        if (simId !== undefined) {
            localVarQueryParameters['sim_id'] = ObjectSerializer.serialize(simId, "Array<string>");
        }

        if (imsi !== undefined) {
            localVarQueryParameters['imsi'] = ObjectSerializer.serialize(imsi, "Array<string>");
        }

        if (msisdn !== undefined) {
            localVarQueryParameters['msisdn'] = ObjectSerializer.serialize(msisdn, "Array<string>");
        }

        if (iccid !== undefined) {
            localVarQueryParameters['iccid'] = ObjectSerializer.serialize(iccid, "Array<string>");
        }

        if (serialNumber !== undefined) {
            localVarQueryParameters['serial_number'] = ObjectSerializer.serialize(serialNumber, "Array<string>");
        }

        if (tag !== undefined) {
            localVarQueryParameters['tag'] = ObjectSerializer.serialize(tag, "Array<string>");
        }

        if (bundles !== undefined) {
            localVarQueryParameters['bundles'] = ObjectSerializer.serialize(bundles, "Array<string>");
        }

        if (sessionStatus !== undefined) {
            localVarQueryParameters['session_status'] = ObjectSerializer.serialize(sessionStatus, "'NA' | 'ONLINE' | 'OFFLINE'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (lastEvaluatedKey !== undefined) {
            localVarQueryParameters['last_evaluated_key'] = ObjectSerializer.serialize(lastEvaluatedKey, "string");
        }

        if (searchType !== undefined) {
            localVarQueryParameters['search_type'] = ObjectSerializer.serialize(searchType, "'and' | 'or'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.api_key.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.api_token.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_token.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Sim>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Sim>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 指定された期間の Subscriber の通信量ランキングを検索して返却します。
     * @summary Subscriber の通信量ランキングを返却する
     * @param from 検索期間の始点 (UNIX 時間 (ミリ秒))
     * @param to 検索期間の終点 (UNIX 時間 (ミリ秒))
     * @param limit 取得する結果の上限数
     * @param order ランキングの順序
     */
    public async searchSubscriberTrafficVolumeRanking (from: number, to: number, limit?: number, order?: 'asc' | 'desc', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<TrafficVolumeRanking>;  }> {
        const localVarPath = this.basePath + '/query/subscribers/traffic_volume/ranking';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'from' is not null or undefined
        if (from === null || from === undefined) {
            throw new Error('Required parameter from was null or undefined when calling searchSubscriberTrafficVolumeRanking.');
        }

        // verify required parameter 'to' is not null or undefined
        if (to === null || to === undefined) {
            throw new Error('Required parameter to was null or undefined when calling searchSubscriberTrafficVolumeRanking.');
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "number");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "'asc' | 'desc'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.api_key.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.api_token.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_token.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<TrafficVolumeRanking>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<TrafficVolumeRanking>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * (非推奨の API です。代わりに `/query/sims` API を利用することを検討してください) Subscriber をクエリに応じて検索します。部分一致したものを返却します。この API 権限が付与された場合、すべての SIM に対して group も含めた検索/一覧取得を行える権限が与えられます。
     * @summary (非推奨) Subscriber をクエリに応じて検索する
     * @param name 検索する Subscriber の名前
     * @param group 検索するグループの名前
     * @param imsi 検索する IMSI
     * @param msisdn 検索する MSISDN
     * @param iccid 検索する ICCID
     * @param serialNumber 検索する製造番号
     * @param tag 検索するタグの値の文字列
     * @param subscription 検索するサブスクリプション (例: &#x60;plan01s&#x60;)
     * @param moduleType 検索するモジュールタイプ (例: &#x60;mini&#x60;, &#x60;virtual&#x60;)
     * @param limit 取得する結果の上限数
     * @param lastEvaluatedKey 現ページで取得した最後の Subscriber の IMSI。このパラメータを指定することで次の Subscriber 以降のリストを取得できる。
     * @param searchType 検索の種別 (AND 検索もしくは OR 検索)
     */
    public async searchSubscribers (name?: Array<string>, group?: Array<string>, imsi?: Array<string>, msisdn?: Array<string>, iccid?: Array<string>, serialNumber?: Array<string>, tag?: Array<string>, subscription?: Array<string>, moduleType?: Array<string>, limit?: number, lastEvaluatedKey?: string, searchType?: 'and' | 'or', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Subscriber>;  }> {
        const localVarPath = this.basePath + '/query/subscribers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "Array<string>");
        }

        if (group !== undefined) {
            localVarQueryParameters['group'] = ObjectSerializer.serialize(group, "Array<string>");
        }

        if (imsi !== undefined) {
            localVarQueryParameters['imsi'] = ObjectSerializer.serialize(imsi, "Array<string>");
        }

        if (msisdn !== undefined) {
            localVarQueryParameters['msisdn'] = ObjectSerializer.serialize(msisdn, "Array<string>");
        }

        if (iccid !== undefined) {
            localVarQueryParameters['iccid'] = ObjectSerializer.serialize(iccid, "Array<string>");
        }

        if (serialNumber !== undefined) {
            localVarQueryParameters['serial_number'] = ObjectSerializer.serialize(serialNumber, "Array<string>");
        }

        if (tag !== undefined) {
            localVarQueryParameters['tag'] = ObjectSerializer.serialize(tag, "Array<string>");
        }

        if (subscription !== undefined) {
            localVarQueryParameters['subscription'] = ObjectSerializer.serialize(subscription, "Array<string>");
        }

        if (moduleType !== undefined) {
            localVarQueryParameters['module_type'] = ObjectSerializer.serialize(moduleType, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (lastEvaluatedKey !== undefined) {
            localVarQueryParameters['last_evaluated_key'] = ObjectSerializer.serialize(lastEvaluatedKey, "string");
        }

        if (searchType !== undefined) {
            localVarQueryParameters['search_type'] = ObjectSerializer.serialize(searchType, "'and' | 'or'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.api_key.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.api_token.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_token.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Subscriber>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Subscriber>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
